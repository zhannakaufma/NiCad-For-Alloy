comments
    //
    --
    /* */
end comments

% name
compounds
    => >= -> <: :> ++ || && <=>
end compoundscompounds

keys 
    abstract       after       `all         always       and
    as             `assert      before      but          check
    disj           else        enabled     event        eventually
    exactly        extends     fact        for          fun
    historically   iden        iff         implies      in
    Int            invariant   let         lone         modifies
    module         no          none        `not          once   
    one            open        or          pred         releases
    run            set         sig         since        some
    steps          sum         triggered   univ         until
    var
    
end keys

tokens
    name "[\a][\a\d_\"]*"
    number "0|([1-9]\d*)"
end tokens

define alloyModule
    [opt moduleDecl] [repeat import] [repeat paragraph]
end define

define moduleDecl
    module [qualName] [opt nameListPlus]
end define

define nameListPlus
    `[ [list name +] `]
end define

define `import
    open [qualName] [opt qualNameListPlus] [opt imAsName]
end define

define qualNameListPlus
    `[ [list qualName +]  `]
end define

define importRule     % normally called import
    open [qualName] [opt qualNameListPlus] [opt asName]
end define

define asName
    as name
end define

define paragraph
    [sigDecl] | [factDecl] | [predDecl] | [funDecl] | [assertDecl] | [cmdDecl]
end define

define sigDecl
    [opt abstract] [opt mult] sig [list name] [opt sigExit] { [list decl] } [opt block]
end define

define sigExt
    extends [qualName] | in [qualName] [repeat plusQualName]
end define

define plusQualName
    + [qualName]
end define

define mult
    lone | some | none
end define

define factDecl
    fact [opt name] [block]
end define

define predDecl
    pred [opt qualNameDot] name [opt paraDecls] [block]

define qualNameDot
    [qualName] .
end define

define funDecl
    fun [opt qualNameDot] name [opt paraDecls] : [expr] { [expr] }
end define

define paraDecls
    ( [list decl] ) | `[ [list decl] `]
end define

define assertDecl
    assert [opt name] [blokc]
end define

define cmdDecl
    [opt nameColon] [opt runOrCheck] [opt qualNameOrBlock] [opt scope]
end define

define runOrCheck
    run | check
end define

define qualNameOrBlock
    [qualName] | [block]
end define

define scope
    for number | [opt butTypeScopeListPlus] | for [list typescope +]
end define

define but butTypeScopeListPlus
    but [list typescope+]
end define


define expr
    [const] | [qualName] | @name | this 
    | [unOp] [expr] | [expr] [binOp] [expr] | [expr] [arrowOp] [expr]
    | [expr] `[ [list expr]  `]
    | [expr] `[! | not`] [compareOp] [expr]
    | [expr] ( => | implies ) [expr] else [expr]
    | let [list letDecl+] [blockOrBar]
    | quant [list decl+] [blockOrBar]
    | {[list decl+] [blockOrBar]}
    | expr '
    | ( [expr] ) | [block]
end define 

define const
    [-] number | none | univ | iden
end define 

define unOp
    ! | not | no | [mult] | set | # | ~ | * | ^
end define

define binOp
    || | or | && | and | <=> | iff | => | implies | & | + | - | ++ | <: | :> | .
end define

define arrowOp
    [multorset] -> [multorset]
end define

define multorset
    [mult] | set
end define

define compareOp
    in | = | < | > | =< | >=
end define 

define letDecl
    name = [expr]
end define

define block
    { [expr*] }
end define

define blockOrBar
    [block] | [bar] [expr]
end define

define quant
    all | no | sum | [mult]
end define

define bar
    `|
end define

define nameslash
    name /
end define

define qualName 
    `[this/`] [nameslash*] name
end define 


