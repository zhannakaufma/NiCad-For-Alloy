comments
    //
    --
    /* */
end comments

% name
compounds
    => >= -> <: :> ++ || && <=>
end compoundscompounds

keys 
    abstract       after       all         always       and
    as             assert      before      but          check
    disj           else        enabled     event        eventually
    exactly        extends     fact        for          fun
    historically   iden        iff         implies      in
    Int            invariant   let         lone         modifies
    module         no          none        not          once   
    one            open        or          pred         releases
    run            set         sig         since        some
    steps          sum         triggered   univ         until
    var
    
end keys

define alloyModule
    [opt moduleDecl] [repeat import] [repeat paragraph]
end define

define moduleDecl
    module [qualName] [opt nameList]
end define

define nameList
    `[ [list name +] `]
end define

define `import
    open [qualName] [opt qualNameList] [opt imAsName]
end define

define qualNameList
    `[ [list qualName +]  `]
end define


























































define expr
    [const] | [qualName] | @name | this 
    | [unOp] [expr] | [expr] [binOp] [expr] | [expr] [arrowOp] [expr]
    | [expr] `[ [list expr]  `]
    | [expr] `[! | not`] [compareOp] [expr]
    | [expr] ( => | implies ) [expr] else [expr]
    | let [list letDecl+] [blockOrBar]
    | quant [list decl+] [blockOrBar]
    | {[list decl+] [blockOrBar]}
    | expr '
    | ( [expr] ) | [block]
end define 

define const
    [-] number | none | univ | iden
end define 

define unOp
    ! | not | no | [mult] | set | # | ~ | * | ^
end define

define binOp
    || | or | && | and | <=> | iff | => | implies | & | + | - | ++ | <: | :> | .
end define

define arrowOp
    [multorset] -> [multorset]
end define

define multorset
    [mult] | set
end define

define compareOp
    in | = | < | > | =< | >=
end define 

define letDecl
    name = [expr]
end define

define block
    { [expr*] }
end define

define blockOrBar
    [block] | [bar] [expr]
end define

define quant
    all | no | sum | [mult]
end define

define bar
    `|
end define

define nameslash
    name /
end define

define qualName 
    `[this/`] [nameslash*] name
end define 


